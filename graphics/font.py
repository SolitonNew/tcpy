"""
Класс является контейнером шрифта. Используется как драйвер шрифтов
для метода textOut класса LCD.
Copyright (c) 2015, Moklyak Alexandr.

Файл шрифта представляет собой бинарный файл созданый отдельной утилитой.
Данные файла содержат точечный оттиск каждого символа ASCII. При создании
экземпляра класса Font необходимо указать путь к файлу шрифта. Сам класс
в начале зачитывает только высоту шрифта.
Позиции символов, их размеры и битовые маски зачитываются каждый раз прямо
из файла. Тем самым немного увеличивается время отображения, но значительно
экономится память.
"""

import math

class Font(object):  
    def __init__(self, fileName):
        self.file = None
        self.fileName = fileName
        self.open()

    def __del__(self):
        self.close()

    def open(self):
        """
        Метод открывает файл шрифта на чтение. При создании этот метод
        вызывается автоматически. Но если файл был закрыт методом close(), этим
        методом его можно открыть заново.
        """
        if not self.file:
            self.file = open(self.fileName, 'rb')
            self.file.seek(31)
            self.height = self.file.read(1)[0] # Читаем высоту шрифта

    def close(self):
        """
        Метод закрывает файловый поток шрифта.
        Не забывайте его вызывать, если шрифт уже не понадобится.
        """
        if self.file: self.file.close()
        self.file = None

    def char_size(self, c):
        """
        Метод выполняет чтение из заголовка файла шрифта позицию в растре и
        ширину символа.
        Возвращает кортеж (позиция, ширина)
        """
        f = self.file
        # Смещаемся в потоке на нужный символ
        f.seek(32 + c * 3)
        p = f.read(3)
        x = (p[1] << 8) + p[0]
        w = p[2]
        return(x, w)
        
    def char_data(self, c):
        """
        Метод для получения точечного представления символа из соответствующего
        файла шрифта.
        Возвращает список битовых масок для отрисовки шрифта.
        """
        cs = self.char_size(c)        
        bh = math.ceil(self.height / 8)
        f = self.file
        # Смещаемся в потоке на нужный символ
        f.seek(32 + 256 * 3 + cs[0] * bh)
        res = []
        # Читаем нужный символ
        for x in range(cs[1]):
            b = 0
            for y in range(bh):
                r = f.read(1)
                b |= r[0] << (y * 8)
            res.append(b)
        return(res)
